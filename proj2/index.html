<html>
	<head>
	</head>
	<body>
		<h1> Project 1 </h1>
		<p>Overview:<br></p>
		<p></p>
		<p>Task 1: <br>
		   The De Casteljau algorithm linearly interpolates the points between the points given as input to the algorithm. It continually repeats this process on the newly created<br>
		   points. Once down to the final point, the algorithm has defined a point on the Bezier curve. I implemented the algorithm by multiplying the coordinates of the first of the pair <br>
		   of coordinates by 1 - t and adding it to the coordinates of the second point multiplied by t. 
		</p>
		<img src="t1i1.png" alt="Task 1 sc 1">
		<p></p>
		<img src="t1i2.png" alt="Task 1 sc 2">
		<p></p>
		<img src="t1i3.png" alt="Task 1 sc 3">
		<p></p>
		<img src="t1i4.png" alt="Task 1 sc 4">
		<p></p>
		<img src="t1i5.png" alt="Task 1 sc 5">
		<p></p>
		<img src="t1i6.png" alt="Task 1 sc 6">
		<p></p>
		<img src="t1i7.png" alt="Task 1 sc 7">
		<p></p>
		<p>Task 2: <br>
		   Essentially, Bezier points along one axis can be grouped together along the other axis and linearly interpolated using the same algorithm to get points that <br>
		   lie on the Bezier curves of both axes, providing a curve for the entire surface. 
		</p>
		<img src="t1pot.png" alt="Task 2 teapot">
		<p></p>
		<p>Task 3: <br>
		   The area weighted vertex normals was calculated by taking the cross product of two of the edges in each of the attached faces of the vertex and summing them up. <br>
		   The cross product provides the normal vector, and since we're using the edges of the triangle, their lengths are being accounted for in the cross product effectively <br>
		   weighting the normals by the areas of the triangles.
		</p>
		<p>Flat shading</p>
		<img src="task3flat.png" alt="Task 3 flat shading">
		<p></p>
		<p>Phong shading</p>
		<img src="task3phong.png" alt="Task 3 phong shading, with the normals">
		<p></p>
		<p>Task 4: <br>
		   At a very high level, implementing the edge flip involved methodically going through every element in the two triangles (vertices, faces, edges) and updating <br>
		   their pointers in order for it to match the expected flip. I didn't do anything particularly special other than following the provided step order. The only thing <br>
	           that wasn't just correct pointer assignment that I did was storing a reference to two particular halfedges that would be needed in a later pointer assignment but would <br>
		   be lost while doing pointer assignments before reaching that point. The check_for() function was also very useful, as it helped when I ran into a weird bug where my <br>
		   program was infinitely stalling, which threw me off since there shouldn't have been any loops in the program. What I found out was that I was assigning two halfedges' <br>
	           next elements to each other on accident because I set them to a sequence of halfedge->next()->next() pointers expecting them to represent certain halfedges. However, <br>
		   I didn't realize that I was changing halfedge->next()->next() earlier, so they ended up representing halfedges different than what I intended.
		</p>
		<p>Preflip teapot:</p>
		<img src="task4preflip.png" alt="Task 4 before flip">
		<p></p>
		<p>Postflips teapot:</p>
		<img src="task4postflips.png" alt="Task 4 after flips">
		<p></p>
		<p>Task 5: <br>
		   This task was almost identical to the previous task except with slightly more bookkeeping because of the need to create new elements. My implementation basically boils <br>
	           down to going through every element and changing them to match with the expected outcome. I followed the image of the split triangle provided in the spec from the new vertex <br>
		   m and just traced through it in my head dozens of times while doing the pointer assignments to get the right element assignments. Debugging was the same was for task 4, but <br>
		   I didn't make any major errors in my first implementation so debugging was simpler. The only issue I had was splitting would result in correctly appearing edges, but the face <br>
		   would disappear. It ended up just being a copy and paste of a previous halfedge assignment that I forgot to change properly. <br>
		   <br>
		   Extra Credit: <br>
		   For extra credit, I also implemented support for splitting on boundary edges. My implementation was very simple; if the input edge's halfedge was a boundary edge, <br>
		   I ignored changing or adding any element that would lie in halfedge's triangle (which would lie in the boundary) and vice versa for if halfedge's twin was a boundary edge. <br>
		   In practice though, halfedge ended up never being a boundary edge in any of my tests. I could kind of reason why this makes sense in my head, but just in case I kept the <br>
		   case for halfedge being a boundary edge in.
		</p>
		<p>Presplits teapot:</p>
		<img src="task5presplits.png" alt="Task 5 before splits">
		<p></p>
		<p>Postsplits teapot:</p>
		<img src="task5postsplits.png" alt="Task 5 after splits">
		<p></p>
		<p>Presplits and flips cow:</p>
		<img src="task5preflipssplits.png" alt="Task 5 before splits and flips">
		<p></p>
		<p>Postsplits and flips cowt:</p>
		<img src="task5postflipssplits.png" alt="Task 5 after splits and flips">
		<p></p>
		<p>Extra Credit: Presplits and flips beetle boundary:</p>
		<img src="task5boundarypresplit.png" alt="Task 5 before splits and flips on boundaries">
		<p></p>
		<p>Extra Credit: Postsplits and flips beetle boundary:</p>
		<img src="task5boundarypostsplit.png" alt="Task 5 after splits and flips on boundaries">
		<p></p>
	</body>
</html>
